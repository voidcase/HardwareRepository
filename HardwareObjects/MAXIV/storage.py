#!/usr/bin/env python

###########################################################################
#     This file is part of Scientific Data Management for Max IV.
#
#     Copyright (C) 2017  MAX IV Laboratory, Lund Sweden.
#
#     This is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 3 of the License, or
#     (at your option) any later version.
#
#     This software is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, see <http://www.gnu.org/licenses/>.
###########################################################################


"""
storage handles the storage for the user data.
"""

import pwd
import os
import grp
import getpass
import logging

__all__ = ['SDM Storage']
__author__ = 'kits'
__docformat__ = 'restructuredtext'


class Storage(object):

    def __init__(self, user_type, beamline, service_account=None, prefix=None):
        """
        Initialise and check the basic storage for one type and one beamline 
        Prepare the user proposal directories

        :param user_type: Type of user to be used: visitor, ...
        :param beamline: String with the Beamline to be used.
        :param service_account: the ownership of the path.
        :param prefix: Default value is None. It's used only for testing purposes.
        """
        self.user_type = user_type
        self.beamline = beamline.lower()
        self.beamline_group = self.beamline
        if not service_account:
            service_account = "{}-service".format(self.beamline)
        self.service_account = service_account
        self.prefix = prefix
        self.__init_beamline_data_path()
        self.__check_beamline_data_path()

    def __init_beamline_data_path(self):
        if self.prefix:
            self.user_type_path = '{0}/data/{1}'.format(self.prefix, self.user_type)
        else:
            self.user_type_path = '/data/{0}'.format(self.user_type)

        self.beamline_path = '{0}/{1}'.format(self.user_type_path, self.beamline.lower())

    def __check_beamline_data_path(self):

        # First check the root path. it should be generated by the system administrator
        if not os.path.exists(self.beamline_path):
            raise StorageException("{} does not exist. It should have been created by your system administrator.".format(self.beamline_path))      
        # Secondly check the ownership of the root path. it should be generated by the system administrator
        st = os.stat(self.beamline_path)
        if self.service_account != pwd.getpwuid(st.st_uid).pw_name:
            raise StorageException("{} does not have the correct user ownership. Please contact your system administrator.".format(self.beamline_path))

        if self.beamline_group != grp.getgrgid(st.st_gid).gr_name:
            raise StorageException("{} does not have the correct group ownership. Please contact your system administrator.".format(self.beamline_path))

    def get_proposal_group(self, proposal, admin=False):
        '''
        Give the corresponding group for a proposal
        '''
        if admin:
            return proposal
        else:
            return proposal + "-group"

    def create_path(self, proposal, proposal_group, visit, username):
        """
        Create and validate the path to use for data acquisition.

        :param proposal: String with the proposal to be used.
        :param visit: String representing the visit.
        :param username: String with the User Name. It will be used to assign
        the ownership of the path.
        :return: It returns an string with the final path that has been generated.
        """
        proposal_path = '{0}/{1}'.format(self.beamline_path, proposal)
        self.fix_path(proposal_path, 02750)
        self.fix_ownership(proposal_path, self.service_account, proposal_group)
        logging.getLogger("HWR").info('[SDM] Proposal path created: %s' %proposal_path)

        visit_path = '{0}/{1}'.format(proposal_path, visit)

        self.fix_path(visit_path, 02770)
        self.fix_ownership(visit_path, self.service_account, proposal_group)
        logging.getLogger("HWR").info('[SDM] Visit path created: %s' %visit_path)

        raw_path = '{0}/{1}'.format(visit_path, 'raw')
        self.fix_path(raw_path, 02770)
        self.fix_ownership(raw_path, self.service_account, proposal_group)
        logging.getLogger("HWR").info('[SDM] Raw path created: %s' %raw_path)

        process_path = '{0}/{1}'.format(visit_path, 'process')
        self.fix_path(process_path, 02770)
        self.fix_ownership(process_path, self.service_account, proposal_group)

        return raw_path

    def fix_path(self, path, mode):
        """
        Fix the mode of the data directory
            :param path: String with the full path to be fixed.
            :param mode: mode of the path.
        :raise StorageException: when the process does not have the ownership
        """
        if not os.path.exists(path):
            os.makedirs(path, mode)
        if self.check_user_ownership(path, getpass.getuser()):
            os.chmod(path, mode)
            os.chmod(path, mode)
        else:
            raise StorageException("The program does not want to change the file mode if not owner by itself. Please contact the owner or a system administrator")

    def check_user_ownership(self, path, user):
        """
        check the user ownership of the new generated folder.
        :param path: String with the full path to be fixed.
        :param user: String of the new user ownership of the path.
        :return: True if the user ownership is correct
        """
        st = os.stat(path)
        path_owner_name = pwd.getpwuid(st.st_uid).pw_name
        return path_owner_name == user

    def check_group_ownership(self, path, group):
        """
        check the group ownership of the new generated folder.
        :param path: String with the full path to be fixed.
        :param group: String of the new group ownership of the path.
        :return: True if the group ownership is correct
        """
        st = os.stat(path)
        path_owner_group = grp.getgrgid(st.st_gid).gr_name
        return path_owner_group == group

    def fix_ownership(self, path, user, group):
        """
        Fix the ownership of the new generated folder.
        !!! Change User is disable since it need root access !!!
        :param path: String with the full path to be fixed.
        :param user: String with the username to give the ownership of the path.
        :param group: String of the new group ownership of the path.
        :return: None
        """
        # @TODO: Maybe we should return True or False if the execution has been successfull.
        # is_writable = os.access(self.path, os.W_OK)
        uid = -1
        gid = -1

        # if self.check_user_ownership(path, user) == False:
        #    uid = pwd.getpwnam(user).pw_uid

        if self.check_group_ownership(path, group) is False:
            gid = grp.getgrnam(group).gr_gid

        os.chown(path, uid, gid)


class StorageException(Exception):
    pass
